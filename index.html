<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Violin & Cello Piano</title>

    <script src="https://surikov.github.io/webaudiofont/npm/dist/WebAudioFontPlayer.js"></script>
    <script src="https://surikov.github.io/webaudiofontdata/sound/0400_FluidR3_GM_sf2_file.js"></script>
    <script src="https://surikov.github.io/webaudiofontdata/sound/0420_FluidR3_GM_sf2_file.js"></script>
    <!-- <script src="https://surikov.github.io/webaudiofontdata/sound/0010_FluidR3_GM_sf2_file.js" -->
    <script src="https://surikov.github.io/webaudiofontdata/sound/0000_FluidR3_GM_sf2_file.js"></script>

    <style>
      body {
        background: #111;
        color: #eee;
        font-family: monospace;
        padding: 10px;
      }

      button {
        margin: 4px;
        padding: 6px 12px;
        cursor: pointer;
      }
      button.active {
        background: #2a7;
        color: #000;
      }

      .piano {
        position: relative;
        height: 90px;
        margin-bottom: 30px;
        user-select: none;
      }

      .white {
        position: absolute;
        width: 16px;
        height: 90px;
        background: #eee;
        border: 1px solid #333;
        box-sizing: border-box;
      }

      .black {
        position: absolute;
        width: 10px;
        height: 55px;
        background: #000;
        z-index: 5;
      }

      .key.active {
        background: #4af !important;
      }

      .label {
        position: absolute;
        bottom: 2px;
        width: 100%;
        font-size: 7px;
        text-align: center;
        pointer-events: none;
        color: #000;
      }
      .black .label {
        color: #ccc;
      }
      .recording {
        outline: 3px solid red;
      }
      #timeline {
        border: 1px solid #333;
        background: #181818;
        padding: 8px;
      }

      .track {
        position: relative;
        height: 40px;
        margin-bottom: 6px;
        background: #222;
      }

      .track-label {
        position: absolute;
        left: 4px;
        top: 2px;
        font-size: 10px;
        color: #aaa;
        z-index: 10;
      }

      .note-block {
        position: absolute;
        top: 14px;
        height: 18px;
        border-radius: 3px;
        background: #4af;
        opacity: 0.9;
      }

      .track.violin .note-block {
        background: #4af;
      }
      .track.cello .note-block {
        background: #7c4;
      }
      .track.piano .note-block {
        background: #fa4;
      }

      .note-block {
        cursor: grab;
      }

      .note-block.dragging {
        opacity: 0.6;
        cursor: grabbing;
      }
    </style>
  </head>

  <body>
    <button id="start">Activate Audio</button><br /><br />

    Sustain:
    <input type="range" id="sustain" min="0" max="3" step="0.05" value="0.6" />
    <span id="sustainVal">0.60s</span><br />

    Vibrato:
    <input type="range" id="vibrato" min="0" max="8" step="0.1" value="0" />
    <span id="vibratoVal">0.0</span>

    <hr />
    <div>
      <button id="octDown">‚¨á Octave</button>
      <span id="octaveLabel">Octave: 0</span>
      <button id="octUp">‚¨Ü Octave</button>
    </div>
    <button id="rangeBtn">üéº Full Range</button>

    <button id="violinBtn" class="active">üéª Violin</button>
    <button id="celloBtn">üéª Cello</button>
    <button id="pianoBtn">üéπ Piano</button>

    <button id="bothBtn">üéª Both</button>
    <hr />
    <button onclick="playLoop()">‚ñ∂Ô∏è Play Loop</button>
    <button onclick="stopLoop()">‚èπ Stop</button>
    <button onclick="clearRecordings()">üßπ Clear Recordings</button>
    <hr />
    <h3>üéº Timeline</h3>
    <div id="timeline"></div>

    <hr />

    <h3>üéª Violin</h3>
    <h3>
      üéª Violin <button onclick="toggleRecord('violin')">‚è∫Ô∏è Record</button>
    </h3>

    <div class="piano" id="violinPiano"></div>

    <h3>üéª Cello</h3>
    <h3>üéª Cello <button onclick="toggleRecord('cello')">‚è∫Ô∏è Record</button></h3>

    <div class="piano" id="celloPiano"></div>

    <h3>üéπ Piano</h3>
    <div class="piano" id="pianoPiano"></div>
    <h3>üéπ Piano <button onclick="toggleRecord('piano')">‚è∫Ô∏è Record</button></h3>

    <script>
      /* ========= AUDIO ========= */
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const player = new WebAudioFontPlayer();
      const VIOLIN = _tone_0400_FluidR3_GM_sf2_file;
      const CELLO = _tone_0420_FluidR3_GM_sf2_file;
      const PIANO = _tone_0000_FluidR3_GM_sf2_file;
      player.loader.decodeAfterLoading(ctx, PIANO);

      player.loader.decodeAfterLoading(ctx, VIOLIN);
      player.loader.decodeAfterLoading(ctx, CELLO);

      start.onclick = () => ctx.resume();
      let octaveOffset = 0;
      let keyToMidi = {};

      // G1 is MIDI 31 ‚Üí find nearest white index
      const GROUP_THRESHOLD = 0.5; // seconds (‚âà human chord timing)

      /* ========= STATE ========= */
      let sustainTime = 0.6;
      let vibratoDepth = 0;
      let mode = "violin";
      const activeNotes = new Map();
      const recordings = {
        violin: [],
        cello: [],
        piano: [],
      };

      const recordingState = {
        violin: false,
        cello: false,
        piano: false,
      };

      let loopLength = 0;
      let recordStartTime = 0;

      /* ========= UI ========= */
      function setMode(m) {
        mode = m;
        violinBtn.classList.toggle("active", m === "violin");
        celloBtn.classList.toggle("active", m === "cello");
        bothBtn.classList.toggle("active", m === "both");
        pianoBtn.classList.toggle("active", m === "piano");

        rebuildKeyMap();
      }

      violinBtn.onclick = () => setMode("violin");
      celloBtn.onclick = () => setMode("cello");
      bothBtn.onclick = () => setMode("both");
      pianoBtn.onclick = () => setMode("piano");

      /* ========= CONTROLS ========= */
      sustain.oninput = (e) => {
        sustainTime = +e.target.value;
        sustainVal.textContent = sustainTime.toFixed(2) + "s";
      };
      vibrato.oninput = (e) => {
        vibratoDepth = +e.target.value;
        vibratoVal.textContent = vibratoDepth.toFixed(1);
      };
      let rangeMode = "full"; // "full" | "real"

      rangeBtn.onclick = () => {
        rangeMode = rangeMode === "full" ? "real" : "full";
        rangeBtn.textContent =
          rangeMode === "full" ? "üéº Full Range" : "üéª Instrument Ranges";
        rebuildKeyMap();
      };
      const RANGES = {
        violin: { min: 55, max: 105 }, // G3 ‚Üí A7
        cello: { min: 36, max: 76 }, // C2 ‚Üí E5
        both: { min: 36, max: 105 },
        piano: { min: 21, max: 108 }, // A0 ‚Üí C8
      };

      /* ========= NOTES ========= */
      const NOTES = [
        "C",
        "C#",
        "D",
        "D#",
        "E",
        "F",
        "F#",
        "G",
        "G#",
        "A",
        "A#",
        "B",
      ];
      const isBlack = (m) => [1, 3, 6, 8, 10].includes(m % 12);
      const noteName = (m) => NOTES[m % 12] + (Math.floor(m / 12) - 1);

      /* ========= KEYBOARD MAP (WHITE KEYS ONLY) ========= */
      // Collect ALL white keys (extended upward)
      // ALL white keys A0 (21) ‚Üí C8 (108)
      const ALL_WHITE_MIDIS = [];
      for (let m = 21; m <= 108; m++) {
        if (![1, 3, 6, 8, 10].includes(m % 12)) {
          ALL_WHITE_MIDIS.push(m);
        }
      }
      const keyboardKeys = [
        "z",
        "x",
        "c",
        "v",
        "b",
        "n",
        "m",
        ",",
        ".",
        "/",
        "a",
        "s",
        "d",
        "f",
        "g",
        "h",
        "j",
        "k",
        "l",
        ";",
        "q",
        "w",
        "e",
        "r",
        "t",
        "y",
        "u",
        "i",
        "o",
        "p",
        "[",
        "]",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "0",
        "-",
        "=",
      ];
      const BASE_WHITE_INDEX = ALL_WHITE_MIDIS.findIndex((m) => m === 31);

      /* ========= AUDIO ENGINE ========= */
      function play(inst, midi, when) {
        const gain = ctx.createGain();
        gain.gain.value = 1;
        gain.connect(ctx.destination);

        if (vibratoDepth > 0) {
          const lfo = ctx.createOscillator();
          const lfoGain = ctx.createGain();
          lfo.frequency.value = 5.5;
          lfoGain.gain.value = vibratoDepth * 0.03;
          lfo.connect(lfoGain).connect(gain.gain);
          lfo.start();
          gain._lfo = lfo;
        }

        player.queueWaveTable(ctx, gain, inst, when, midi, 30, 0.6);
        return gain;
      }
      const TIMELINE_SCALE = 120; // pixels per second
      function renderTimeline() {
        const tl = document.getElementById("timeline");
        tl.innerHTML = "";

        ["violin", "cello", "piano"].forEach((inst) => {
          const track = document.createElement("div");
          track.className = `track ${inst}`;

          const label = document.createElement("div");
          label.className = "track-label";
          label.textContent = inst.toUpperCase();
          track.appendChild(label);

          const groups = groupNotes(recordings[inst]);

          groups.forEach((group) => {
            const start = Math.min(...group.map((n) => n.start));
            const end = Math.max(...group.map((n) => n.start + n.duration));

            const block = document.createElement("div");
            block.className = "note-block";
            block.style.left = start * TIMELINE_SCALE + "px";
            block.style.width = (end - start) * TIMELINE_SCALE + "px";

            enableGroupDrag(block, group);

            track.appendChild(block);
          });

          tl.appendChild(track);
        });
      }

      function noteOn(key) {
        if (activeNotes.has(key) || !(key in keyToMidi)) return;

        const midi = keyToMidi[key];
        const startTime = ctx.currentTime;

        const data = [];

        if (mode === "violin") data.push(play(VIOLIN, midi, startTime));
        if (mode === "cello") data.push(play(CELLO, midi, startTime));
        if (mode === "both") {
          data.push(play(VIOLIN, midi, startTime));
          data.push(play(CELLO, midi, startTime));
        }
        if (mode === "piano") data.push(play(PIANO, midi, startTime));

        if (recordingState[mode]) {
          recordings[mode].push({
            midi,
            start: startTime - recordStartTime,
            duration: null,
          });
        }

        activeNotes.set(key, { data, midi, startTime });
        setHighlight(midi, true);
      }
      function noteOff(key) {
        const note = activeNotes.get(key);
        if (!note) return;

        const now = ctx.currentTime;

        if (recordingState[mode]) {
          const rec = recordings[mode].find(
            (r) => r.midi === note.midi && r.duration === null,
          );

          if (rec) {
            rec.duration = now - note.startTime + sustainTime;
          }
        }

        note.data.forEach((g) => {
          g.gain.linearRampToValueAtTime(0, now + sustainTime);
        });

        setHighlight(note.midi, false);
        activeNotes.delete(key);
      }
      let loopTimer = null;

      function playLoop() {
        stopLoop();

        const start = ctx.currentTime + 0.1;

        Object.entries(recordings).forEach(([inst, notes]) => {
          notes.forEach((n) => {
            const instrument =
              inst === "violin" ? VIOLIN : inst === "cello" ? CELLO : PIANO;

            player.queueWaveTable(
              ctx,
              ctx.destination,
              instrument,
              start + n.start,
              n.midi,
              n.duration,
              0.6,
            );
          });
        });

        loopTimer = setTimeout(playLoop, loopLength * 1000);
      }

      function stopLoop() {
        if (loopTimer) clearTimeout(loopTimer);
      }

      /* ========= INPUT ========= */

      window.addEventListener("keyup", (e) => noteOff(e.key));

      /* ========= VISUAL ========= */
      function setHighlight(midi, on) {
        document
          .querySelectorAll(`[data-midi="${midi}"]`)
          .forEach((k) => k.classList.toggle("active", on));
      }
      function clearRecordings() {
        Object.keys(recordings).forEach((k) => (recordings[k] = []));
        loopLength = 0;
        stopLoop();
        renderTimeline();
      }

      /* ========= BUILD PIANO ========= */
      function buildPiano(id) {
        const el = document.getElementById(id);
        el.innerHTML = "";
        let whiteX = 0;
        const whitePos = {};
        for (let m = 24; m <= 119; m++) {
          if (!isBlack(m)) {
            const w = document.createElement("div");
            w.className = "white key";
            w.dataset.midi = m;
            w.style.left = whiteX + "px";
            w.innerHTML = `
  <div class="label">
    <div class="note">${noteName(m)}</div>
    <div class="kbd"></div>
  </div>
`;

            el.appendChild(w);
            whitePos[m] = whiteX;
            whiteX += 16;
          }
        }

        for (let m = 24; m <= 119; m++) {
          if (isBlack(m)) {
            const prev = m - 1;
            if (!(prev in whitePos)) continue;
            const b = document.createElement("div");
            b.className = "black key";
            b.dataset.midi = m;
            b.style.left = whitePos[prev] + 11 + "px";
            b.innerHTML = `<div class="label">${noteName(m)}</div>`;
            el.appendChild(b);
          }
        }
      }
      function toggleRecord(inst) {
        recordingState[inst] = !recordingState[inst];

        if (recordingState[inst]) {
          recordings[inst] = [];
          recordStartTime = ctx.currentTime;
          console.log(`Recording ${inst}`);
        } else {
          loopLength = Math.max(loopLength, ctx.currentTime - recordStartTime);
          console.log(`Stopped ${inst}`);
        }
        if (!recordingState[inst]) {
          loopLength = Math.max(loopLength, ctx.currentTime - recordStartTime);
          renderTimeline();
        }

        document.body.classList.toggle("recording", recordingState[inst]);
      }
      function groupNotes(notes) {
        const sorted = [...notes].sort((a, b) => a.start - b.start);
        const groups = [];

        let current = [];

        sorted.forEach((note) => {
          if (
            current.length === 0 ||
            note.start - current[0].start <= GROUP_THRESHOLD
          ) {
            current.push(note);
          } else {
            groups.push(current);
            current = [note];
          }
        });

        if (current.length) groups.push(current);

        return groups;
      }

      function rebuildKeyMap() {
        keyToMidi = {};

        keyboardKeys.forEach((key, i) => {
          const idx = BASE_WHITE_INDEX + i + octaveOffset * 7;
          let midi = ALL_WHITE_MIDIS[idx];
          if (!midi) return;

          if (rangeMode === "real") {
            if (mode === "violin" && (midi < 55 || midi > 105)) return;
            if (mode === "cello" && (midi < 36 || midi > 76)) return;
            if (mode === "both") {
              if (midi < 36 || midi > 105) return;
            }
            if (mode === "piano") {
              if (midi < 21 || midi > 108) return;
            }
          }

          keyToMidi[key] = midi;
        });
        updateKeyLabels();
        updateRangeVisual();

        octaveLabel.textContent = `Octave: ${octaveOffset}`;
      }

      rebuildKeyMap();
      window.addEventListener("keydown", (e) => {
        if (e.repeat) return;

        if (e.key === "`") {
          octaveOffset = Math.max(octaveOffset - 1, -5);
          rebuildKeyMap();
          return;
        }

        if (e.key === "~") {
          octaveOffset = Math.min(octaveOffset + 1, 5);
          rebuildKeyMap();
          return;
        }

        noteOn(e.key);
      });
      octDown.onclick = () => {
        octaveOffset = Math.max(octaveOffset - 1, -5);
        rebuildKeyMap();
      };

      octUp.onclick = () => {
        octaveOffset = Math.min(octaveOffset + 1, 5);
        rebuildKeyMap();
      };
      function updateKeyLabels() {
        // clear all keyboard labels
        document
          .querySelectorAll(".kbd")
          .forEach((el) => (el.textContent = ""));

        // apply current mappings
        for (const [key, midi] of Object.entries(keyToMidi)) {
          document
            .querySelectorAll(`[data-midi="${midi}"] .kbd`)
            .forEach((el) => (el.textContent = key.toUpperCase()));
        }
      }
      function updateRangeVisual() {
        document.querySelectorAll(".key").forEach((k) => {
          const midi = +k.dataset.midi;
          k.classList.remove("disabled");

          if (rangeMode === "real") {
            const r = RANGES[mode];
            if (midi < r.min || midi > r.max) {
              k.classList.add("disabled");
            }
          }
        });
      }
      function enableDrag(block, note) {
        let startX = 0;
        let originalLeft = 0;

        block.addEventListener("mousedown", (e) => {
          e.preventDefault();
          startX = e.clientX;
          originalLeft = note.start;

          block.classList.add("dragging");

          const onMove = (e) => {
            const dx = e.clientX - startX;
            const deltaTime = dx / TIMELINE_SCALE;

            note.start = Math.max(0, originalLeft + deltaTime);
            block.style.left = note.start * TIMELINE_SCALE + "px";
          };

          const onUp = () => {
            block.classList.remove("dragging");
            window.removeEventListener("mousemove", onMove);
            window.removeEventListener("mouseup", onUp);
          };

          window.addEventListener("mousemove", onMove);
          window.addEventListener("mouseup", onUp);
        });
      }
      function enableGroupDrag(block, group) {
        let startX = 0;
        let originalStarts = [];

        block.addEventListener("mousedown", (e) => {
          e.preventDefault();

          startX = e.clientX;
          originalStarts = group.map((n) => n.start);

          block.classList.add("dragging");

          const onMove = (e) => {
            const dx = e.clientX - startX;
            const delta = dx / TIMELINE_SCALE;

            group.forEach((note, i) => {
              note.start = Math.max(0, originalStarts[i] + delta);
            });

            const newStart = Math.min(...group.map((n) => n.start));
            block.style.left = newStart * TIMELINE_SCALE + "px";
          };

          const onUp = () => {
            block.classList.remove("dragging");
            window.removeEventListener("mousemove", onMove);
            window.removeEventListener("mouseup", onUp);
          };

          window.addEventListener("mousemove", onMove);
          window.addEventListener("mouseup", onUp);
        });
      }

      buildPiano("pianoPiano");

      buildPiano("violinPiano");
      buildPiano("celloPiano");
    </script>
  </body>
</html>
